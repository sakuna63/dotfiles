" quickrun {{
" markdownのHTML変換後にブラウザを開く

let g:quickrun_config = {}
let g:quickrun_config.markdown = {
      \ 'type': 'markdown/gfm',
      \ 'cmdopt': '-s --mathjax -c ~/.vim/github.min.css',
      \ 'outputter': 'browser'
      \ }
" }}

" neosnippet {{

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

let g:neosnippet#enable_snipmate_compatibility = 1
let g:neosnippet#snippets_directory='~/.vim/bundle/neosnippet-snippets, ~/.vim/snippets'

" }}

" tweetvim {{

let g:tweetvim_tweet_per_page = 50
let g:tweetvim_cache_size = 10
let g:tweetvim_display_source = 1
let g:tweetvim_display_time = 1
let g:tweetvim_display_icon = 1
let g:tweetvim_display_username = 1

" }}

" emmet {{

let g:user_emmet_settings = {
\   'lang' : 'ja'
\ }

" }}

" vim-endwise {{{

let g:endwise_no_mappings=1

" }}}

" previm {{{

let g:previm_open_cmd = "open"
nnoremap <silent> <F7> :PrevimOpen<CR>

" }}}

" ConqueTerm {{{

let g:ConqueTerm_ReadUnfocused = 1
let g:ConqueTerm_CloseOnEnd = 1
let g:ConqueTerm_StartMessages = 0
let g:ConqueTerm_CWInsert = 1
noremap <silent> <Leader>sh :ConqueTermVSplit zsh<CR>

function! s:delete_ConqueTerm(buffer_name)
    let term_obj = conque_term#get_instance(a:buffer_name)
    call term_obj.close()
endfunction
autocmd BufWinLeave zsh\s-\s? call <SID>delete_ConqueTerm(expand('%'))

" }}}

"------------------------------------
"SingleCompile
"------------------------------------

nmap <F9> :SCCompile<cr>
nmap <F10> :SCCompileRun<cr>


"------------------------------------
" vim-over
"------------------------------------

" over.vimの起動
nnoremap <silent> <Leader>m :OverCommandLine<CR>

" カーソル下の単語をハイライト付きで置換
nnoremap sub :OverCommandLine<CR>%s/<C-r><C-w>//g<Left><Left>

" コピーした文字列をハイライト付きで置換
nnoremap subp y:OverCommandLine<CR>%s!<C-r>=substitute(@0, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>

"------------------------------------
" unite.vim
"------------------------------------

let g:unite_source_history_yank_enable = 1

nnoremap [unite] <Nop>
nmap <Space>u [unite]

nnoremap <silent> [unite]c :UniteWithCurrentDir -buffer-name=files file_mru buffer bookmark file<CR>
nnoremap <silent> [unite]y :Unite history/yank<CR>
nnoremap <silent> [unite]o :Unite outline<CR>
nnoremap <silent> [unite]f :VimFiler<CR>
nnoremap <silent> [unite]t :Unite tweetvim<CR>

nnoremap [urails] <Nop>
nmap [unite]r [urails]

nnoremap <silent> [urails]r :Unite rails/route<CR>
nnoremap <silent> [urails]m :Unite rails/model<CR>
nnoremap <silent> [urails]c :Unite rails/controller<CR>
nnoremap <silent> [urails]v :Unite rails/view<CR>

"------------------------------------
" neocomplete
"------------------------------------

" AutoComplPopというプラグインを無効化する（競合するため）
let g:acp_enableAtStartup = 0
" 起動時にneocompleteを有効化する
let g:neocomplete#enable_at_startup = 1
" 大文字小文字を区別せずに補完する
let g:neocomplete#enable_smart_cast = 1
" シンタックスを記憶する最小の文字数（変数名などが３文字以上である場合に記憶される）
let g:neocomplete#sources#syntax#min_keyword_length = 3
" neocompleteを自動的にロック（使用しない？）バッファ名のパターンを指定する。ku.vimなどneocompleteと相性の悪いプラグインを避けるため
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" キャメルケース補完
"let g:neocomplete_enable_camel_case_completion = 1
" スネークケース補完
"let g:neocomplete_enable_underbar_completion = 1

" ファイルタイプごとに独自のディクショナリを追加する
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }


" オリジナルのキーワードを定義する
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" 補完キャンセル
inoremap <expr><C-g>     neocomplete#undo_completion()
" 補完候補から共通する部分を補完する
inoremap <expr><C-l>     neocomplete#complete_common_string()

" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction

" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" 文字削除時にポップアップを閉じる<BS> = BackSpace
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" 現在選択している候補を確定する
inoremap <expr><C-y>  neocomplete#close_popup()
" 選択をキャンセルし、ポップアップを閉じる
inoremap <expr><C-e>  neocomplete#cancel_popup()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=nodejscomplete#CompleteJS
" autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
